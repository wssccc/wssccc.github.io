<?xml version="1.0" encoding="UTF-8" ?>    <rss version="2.0">
        <channel>
            <title>wssccc in action</title>
            <description>wssccc</description>
            <link>http://wssccc.github.io/blog/</link>
            <lastBuildDate>2014-06-14 11:19:21</lastBuildDate>
            <pubDate>2014-06-14 11:19:21</pubDate>
                            <item>
                    <title>Joel的12问</title>
                    <link>http://wssccc.github.io/blog/joel-q12</link>
                    <guid>http://wssccc.github.io/blog/joel-q12</guid>
                    <pubDate>2014-06-14 00:00</pubDate>
                    <description><![CDATA[<ul>
<li><p>你们使用源代码控制吗</p></li>
<li><p>你们每步都做构建吗</p></li>
<li><p>你们做每日构建吗</p></li>
<li><p>你们有缺陷数据库吗</p></li>
<li><p>你们会在写新代码之前修复缺陷吗</p></li>
<li><p>你们有与当前工作吻合的进度安排吗</p></li>
<li><p>你们有规约吗</p></li>
<li><p>程序员工作环境安静吗</p></li>
<li><p>你们采用了市面上最好的工具吗</p></li>
<li><p>你们有测试人员吗</p></li>
<li><p>你们会要求应聘者在面试时写代码吗</p></li>
<li><p>你们做走廊可用性测试吗</p></li>
</ul>
]]></description>
                </item>
                                <item>
                    <title>饼干君的原理</title>
                    <link>http://wssccc.github.io/blog/inside-biscuit</link>
                    <guid>http://wssccc.github.io/blog/inside-biscuit</guid>
                    <pubDate>2014-06-05 00:00</pubDate>
                    <description><![CDATA[<p><em>之前貌似有一篇饼干君做符号微分的<a href="../../posts/biscuit-diff/">文章</a></em></p>

<p><em>应赵伯要求整理出以前写过的一篇讲饼干君聊天的原理的东西，原文在<a href="http://cloudbbs.org/forum.php?mod=viewthread&amp;tid=20040">SAE的bbs上</a>。</em></p>

<p><br/></p>

<p>sae给我们提供了分词服务，使用它可以很容易实现一个聊天机器人。 </p>

<p>首先我们需要一个语料数据库，语料数据库的内容格式是一个句子，和它对应的回答。这样的格式可以很容易地收集到大量数据，比如对白，聊天记录什么的。 </p>

<p>聊天机器人需要解决的问题是怎样从大量语料数据中找到最合适的回答。直接从输入语句找到回答是很复杂的，但是我们可以从语料数据库中找到最接近输入的句子，然后将它的对应的回答作为输入句子的回答。 </p>

<p>比如数据库中有记录  </p>

<table cellspacing="0" class="t_table" style="width:50%">

    <tbody>

        <tr>

            <td> 1</td><td> 你好</td><td>好</td>

        </tr>

        <tr>

            <td> 2</td><td> 你好吗</td><td>我很好 </td>

        </tr>

    </tbody>

</table>

<p>那么对于一个输入 </p>

<blockquote>
  <p>你最近好吗</p>
</blockquote>

<p>应该是匹配到</p>

<blockquote>
  <p>我很好</p>
</blockquote>

<p>这个回答上，而不是<code>好</code>这个回答 </p>

<p>下面来介绍一下具体的实现过程。 </p>

<p>首先我们需要将输入句子划分为很多段。划分的方法有很多种，最简单的是直接划分成字符数组。但是划分成字符数组有一些问题，因为句子是由词语组成的，直接划分成一个一个的字，就丢失了很多有用的信息，这对于后面的查找和匹配会产生一些影响。所以这里使用sae分词，可以很好的将句子有意义地划分成词语。 </p>

<p>上面的句子可以划分成</p>

<blockquote>
  <p>[0] => Array ( [word] => 你 [word_tag] => 123 [index] => 0 )</p>
  
  <p>[1] => Array ( [word] => 最近 [word_tag] => 132 [index] => 1 ) </p>
  
  <p>[2] => Array ( [word] => 好 [word_tag] => 10 [index] => 2 ) </p>
  
  <p>[3] => Array ( [word] => 吗 [word_tag] => 160 [index] => 3 )</p>
</blockquote>

<p>这里的word_tag是词语的属性，我们可以用它过滤掉一些无用的词语和标点符号。得到词语的数组之后，在数据库中找到包含各个词的记录集合。</p>

<table cellspacing="0" class="t_table" style="width:50%">

    <tbody>

        <tr>

            <td> 你</td><td> 1,2</td></tr><tr><td> 最近</td><td> 空</td>

        </tr>

        <tr>

            <td> 好</td><td> 1,2</td></tr><tr><td> 吗</td><td> 2</td>

        </tr>

    </tbody>

</table>

<p>然后找出记录集中出现最多的记录id，很明显可以看出应该选择2作为回答。这里因为数据量比较小，所以只有一个，实际上记录id也可能会是很多个，因为也可能出现多个回答都很适合的情况，这时候可以随机从中取一个作为结果。 </p>

<p>找到记录id之后，再从数据库中找到对应的记录，它的回答字段就是我们要找的合适的回答了。 </p>

<p>说了这么多，现在来编码实现。</p>

<pre class="brush: php">

<?php

/*

*  wssccc all rights reserved

*/

if (is_string($_GET['msg'])) {

  $str = $_GET['msg'];

} else {

  echo 'no input';

  exit();

}

$disabledTags = array(SaeSegment::POSTAG_ID_V_SH, SaeSegment::POSTAG_ID_W_SP, SaeSegment::POSTAG_ID_W_S,

  SaeSegment::POSTAG_ID_W_R, SaeSegment::POSTAG_ID_W_L, SaeSegment::POSTAG_ID_W_H,

  SaeSegment::POSTAG_ID_W_D, SaeSegment::POSTAG_ID_W);

$saeSeg = new SaeSegment();

$rawSegResult = $saeSeg->segment($str, 1);

// 失败时输出错误码和错误信息

if ($rawSegResult === false) {

  var_dump($saeSeg->errno(), $saeSeg->errmsg());

}

//处理词语数组

$segResult = array();

foreach ($rawSegResult as $elem) {

  //删除禁用的词语类型

  if (!in_array($elem['word_tag'], $disabledTags)) {

    array_push($segResult, $elem);

  }

}

echo '<br>分词结果：<br>';

var_dump($segResult);  //输出

echo '<br>';

$hitSet = array(); //命中集合

$mysql = new SaeMysql();

//查询包含每个词语的记录集合

foreach ($segResult as $segitem) {

  $sql = "SELECT id FROM corpus where txt like '%" . $segitem['word'] . "%'";

  $data = $mysql->getData($sql);

  if ($data != NULL) {

    foreach ($data as $row) {

    //把结果存到临时变量

    $id = $row['id'];

    if (isset($hitSet[$id])) {

      ++$hitSet[$id];

    } else {

      $hitSet[$id] = 1;

    }

    }

  }

}

if ($mysql->errno() != 0) {

  die('Error:' . $mysql->errmsg());

}

var_dump($hitSet);

if (count($hitSet) > 0) {

  $maxhit = -1;

  $maxhitIds = array(); //最大命中的id集合

  foreach ($hitSet as $hitid => $cnt) {

    if ($cnt > $maxhit) {

    $maxhit = $cnt;

    $maxhitIds = array($hitid);

    }else if ($cnt == $maxhit) {

    array_push($maxhitIds, $hitid);

    }

  }

} else {

  echo 'not found';

  exit();

}

var_dump($maxhitIds);

//随机选择一个

$selected = $maxhitIds[array_rand($maxhitIds)];

//通过id找到对应的

$sql = "SELECT response FROM corpus WHERE id =$selected";

$data = $mysql->getVar($sql);

if ($data != NULL) {

  $str = $data;

}

$mysql->closeDb();

echo '回答: ' . $str;

</pre>

<p><a href="http://bbswssccc.sinaapp.com/tools/talk.php">测试网址</a></p>
]]></description>
                </item>
                                <item>
                    <title>ngscript加入了coroutine支持</title>
                    <link>http://wssccc.github.io/blog/ngscript-coroutine</link>
                    <guid>http://wssccc.github.io/blog/ngscript-coroutine</guid>
                    <pubDate>2014-05-04 00:00</pubDate>
                    <description><![CDATA[<h2>为什么使用协程</h2>

<p>在写ngscript的shell时遇到一点问题，于是想到了很久之前看过的lua的协程，觉得似乎有那么点意思。</p>

<p>问题是这样的，最开始ngscript版本中，是一次性读入全部文件的内容到一个字符串中，然后依次进行词法分析，语法分析，得到AST之后拿AST去编译出虚拟机汇编。</p>

<p>后来因为要做shell，也就是一边输入一边进行编译的过程。因为输入有可能是不完全的，完整的程序可能分很多次发送过来，这样，就需要有一个机制来判定什么时候该编译了。比如这样的输入</p>

<pre class="brush: js">

    function fn () { //回车1

        println("fn call"); //回车2

    } //回车3

</pre>

<p>正确的处理方式应该是，在回车1和回车2处提示用户继续输入，在回车3处进行编译过程。</p>

<p>最直观的方法是不停的尝试编译，如果出错则等待下一次输入。当然这个显然不行 = =</p>

<p>于是尝试把整个过程改成流，大概就是</p>

<blockquote>
  <p>字符流-> 词素流 -> AST流</p>
</blockquote>

<p>AST流的输出到编译部分，是以statement为单位的，因为statement貌似是最小可编译的结构。</p>

<p>运行起来之后，大概是这个样子。调用compile，compile向parser要AST，parser向lexer要token，lexer则向字符流要字符。</p>

<p>当某个环节产生可以返回的东西后，则传回到上一层执行。</p>

<p>因为会在字符流阻塞，于是整个compile过程需要一个单独的线程来跑。</p>

<p>这样问题又来了。在交互中输出信息（执行产生的一些东西和AST、ASM）是同步返回的，但是因为流需要阻塞又不得不使用线程，</p>

<p>所以又加了个同步锁。</p>

<p>写到这里我总感觉打开的方式似乎有问题……</p>

<p>我想到了协程。<a href="http://zh.wikipedia.org/zh-cn/%E5%8D%8F%E7%A8%8B">http://zh.wikipedia.org/zh-cn/%E5%8D%8F%E7%A8%8B</a></p>

<p>以前的lexer中的读字符是在一个大while中，当流返回eof的时候while退出。其它时间则在流的read函数处阻塞着。</p>

<p>正是这个read，让我不得不加入另外一个线程来跑它。</p>

<p>如果Java有协程的话，实际上可以这样来设计。</p>

<p>把lexer的读入过程创建为一个协程，在while中判断如果流不可用，则yield回去。</p>

<p>其他部分大抵也是如此。这样一来，整个过程（lex、parse、compile）又是同步的了。</p>

<p>当下一次有输入时，首先把输入的东西写进流，然后依次resume。yield回来的东西就是输出。</p>

<p>但是Java没有协程……我不得不把需要阻塞的函数改名成feed，然后把原来大while中的内部状态写到类成员中保存，使feed看起来是可重入的。</p>

<h2>ngscript中的协程</h2>

<del>

ngscript中的协程实现是一个类。用一个函数对象和参数列表初始化，就可以调用了。

命名也是参考了lua的resume,yield,status三个函数。



实现方式是，在resume中，把调用resume的frame，替换成调用函数的frame（主要是为了函数前面初始化形参变量的过程），

然后切换环境，进入函数执行。这里有个小trick是，栈顶返回地址写的不是resume的返回地址，而是一段特别为了hook return的代码的地址。

在这段代码中，会把当前coroutine的状态置为returned，然后再正常的返回。



而在yield中，主要是把当前代码地址保存下来，然后找到真实的返回地址返回。



ngscript关于coroutine的部分

[https://github.com/wssccc/ngscript/blob/master/README.md#coroutine](https://github.com/wssccc/ngscript/blob/master/README.md#coroutine)

</del>

<h3>5.7更新：</h3>

<p>昨天发现这个实现里面有一个bug，就是在协程函数体内部，把yield方法的引用传给更内层的函数，然后在更内层(= =)的函数yield出来时，就会出现类型错误。</p>

<p>因为yield出来时没有恢复堆栈，一层的时候（只在resume进去的那个函数内调用yield）不会有错，如果在往内堆栈就不对了。</p>

<p>现在ngscript使用的activation record保存方式是直接放在栈上，这样实现continuation也会有问题。</p>
]]></description>
                </item>
                                <item>
                    <title>try ngscript online</title>
                    <link>http://wssccc.github.io/blog/ngscript-online-demo</link>
                    <guid>http://wssccc.github.io/blog/ngscript-online-demo</guid>
                    <pubDate>2014-04-29 22:55</pubDate>
                    <description><![CDATA[<p>ngscript本地编译的版本已经弄好很久了，于是就考虑放一个到SAE上用。</p>

<p>为了适应web的交互模式，parser部分改动很大。</p>

<p>一些链接</p>

<ul>
<li><p><a href="http://ngscript.org/">一个简单的指南</a></p></li>
<li><p><a href="http://shell.ngscript.org/">ngscript shell</a></p></li>
</ul>
]]></description>
                </item>
                                <item>
                    <title>ngscript之三：语法设计</title>
                    <link>http://wssccc.github.io/blog/ngscript-part-4</link>
                    <guid>http://wssccc.github.io/blog/ngscript-part-4</guid>
                    <pubDate>2014-04-06 13:10</pubDate>
                    <description><![CDATA[<p>这是第四篇了，之所以隔了这么久才写，一方面是因为最近开始实习了，另一方面是因为设计语法真是要考虑很多东西。</p>

<p>于是我去读了<a href="http://book.douban.com/subject/25735333/">这本书</a>，里面实现了两种语言，一种跟js差不多语法，用ast解释执行；另一种语法类似java，编译成字节码执行。</p>

<p>于是ngscript就愉快的决定使用类似js语法、编译成字节码了。</p>

<p>这之间还看了一本《flex与bison》，主要看了看LALR（1）中冲突的处理和写文法要注意的事情。</p>

<p>parseroid加上这个描述，就可以分析出ngscript程序的语法树。大概是这个样子</p>

<p><img src="ngscript-ast.png" alt="ngscript-ast.png" /></p>

<p>现在的BNF已经写成下面这个样子了。可能还会不断的改。常用的控制结构和try…catch都有。</p>

<p>生成树之后就是编译成字节码了，这个会在下一篇中详述。</p>

<pre><code>//starter symbol 

%start &lt;program&gt;;

%array &lt;statements&gt; &lt;param_list&gt; &lt;params&gt;;

%equiv &lt;expr&gt; &lt;expr1&gt; &lt;expr2&gt; &lt;expr3&gt; &lt;expr4&gt; &lt;expr5&gt; &lt;expr6&gt; &lt;expr7&gt; &lt;expr8&gt; &lt;nullable_expr&gt;;

%filter semicolon comma;



&lt;program&gt; ::= &lt;statements&gt;;

//----------------------------------------------------------------------------

//statements is a collection of statement;

&lt;statements&gt; ::= NULL;

&lt;statements&gt; ::= &lt;statement&gt; &lt;statements&gt;;

//----------------------------------------------------------------------------

//statement forms

%equiv &lt;statement&gt; &lt;flow_statement&gt; &lt;expr_statement&gt; &lt;fc_statement&gt;;

&lt;statement&gt; ::= &lt;flow_statement&gt;;

&lt;statement&gt; ::= &lt;expr_statement&gt;;

&lt;statement&gt; ::= &lt;fc_statement&gt;;

&lt;statement&gt; ::= &lt;throw_exception&gt;;

&lt;flow_statement&gt; ::= &lt;function_decl&gt;;

&lt;flow_statement&gt; ::= &lt;if_block&gt;;

&lt;flow_statement&gt; ::= &lt;for_block&gt;;

&lt;flow_statement&gt; ::= &lt;if_else_block&gt;;

&lt;flow_statement&gt; ::= &lt;while_block&gt;;

&lt;flow_statement&gt; ::= &lt;try_block&gt;;

&lt;flow_statement&gt; ::= &lt;switch_block&gt;;

&lt;expr_statement&gt; ::= &lt;expr&gt; semicolon;

&lt;throw_exception&gt; ::= throw &lt;expr&gt; semicolon =&gt; &lt;expr&gt;;

&lt;fc_statement&gt; ::= &lt;return_val&gt;;

&lt;fc_statement&gt; ::= &lt;return_void&gt;;

&lt;fc_statement&gt; ::= break semicolon;

&lt;fc_statement&gt; ::= continue semicolon;

&lt;return_val&gt; ::= return &lt;expr&gt; semicolon =&gt; &lt;expr&gt;;

&lt;return_void&gt; ::= return semicolon;

//error handling

//&lt;statement&gt; ::= ERROR semicolon;

//----------------------------------------------------------------------------

//details of function declaration

&lt;function_decl&gt; ::= function ident lparen &lt;param_list&gt; rparen lcurly &lt;statements&gt; rcurly

    =&gt;    ident &lt;param_list&gt; &lt;statements&gt;;

&lt;param_list&gt; ::= ident comma &lt;param_list&gt;;

&lt;param_list&gt; ::= ident;

&lt;param_list&gt; ::= NULL;

//----------------------------------------------------------------------------

//details of if block and else

&lt;if_block&gt; ::= if lparen &lt;expr&gt; rparen lcurly &lt;statements&gt; rcurly

    =&gt; &lt;expr&gt; &lt;statements&gt; ;

&lt;if_else_block&gt; ::= if lparen &lt;expr&gt; rparen lcurly &lt;statements&gt; rcurly else lcurly &lt;statements&gt; rcurly 

    =&gt; &lt;expr&gt; &lt;statements&gt; &lt;statements&gt;;

//----------------------------------------------------------------------------

//details of expr

&lt;expr&gt; ::= &lt;expr&gt; assign &lt;expr1&gt;                =&gt; assign &lt;expr&gt; &lt;expr1&gt;;

&lt;expr&gt; ::= &lt;expr&gt; sub_assign &lt;expr1&gt;            =&gt; sub_assign &lt;expr&gt; &lt;expr1&gt;;

&lt;expr&gt; ::= &lt;expr1&gt;;

&lt;expr1&gt; ::= &lt;expr1&gt; or &lt;expr2&gt;                  =&gt; or &lt;expr1&gt; &lt;expr2&gt;;

&lt;expr1&gt; ::= &lt;expr2&gt;;

&lt;expr2&gt; ::= &lt;expr2&gt; and &lt;expr3&gt;                 =&gt; and &lt;expr2&gt; &lt;expr3&gt;;

&lt;expr2&gt; ::= &lt;expr3&gt;;

&lt;expr3&gt; ::= &lt;expr3&gt; eq &lt;expr4&gt;             =&gt; eq &lt;expr3&gt; &lt;expr4&gt;;

&lt;expr3&gt; ::= &lt;expr3&gt; neq &lt;expr4&gt;          =&gt; neq &lt;expr3&gt; &lt;expr4&gt;;

&lt;expr3&gt; ::= &lt;expr4&gt;;

&lt;expr4&gt; ::= &lt;expr4&gt; gt &lt;expr5&gt;                  =&gt; gt &lt;expr4&gt; &lt;expr5&gt;;

&lt;expr4&gt; ::= &lt;expr4&gt; lt &lt;expr5&gt;                  =&gt; lt &lt;expr4&gt; &lt;expr5&gt;;

&lt;expr4&gt; ::= &lt;expr4&gt; ge &lt;expr5&gt;                  =&gt; ge &lt;expr4&gt; &lt;expr5&gt;;

&lt;expr4&gt; ::= &lt;expr4&gt; le &lt;expr5&gt;                  =&gt; le &lt;expr4&gt; &lt;expr5&gt;;

&lt;expr4&gt; ::= &lt;expr5&gt;;

&lt;expr5&gt; ::= &lt;expr5&gt; add &lt;expr6&gt;                 =&gt; add &lt;expr5&gt; &lt;expr6&gt;;

&lt;expr5&gt; ::= &lt;expr5&gt; sub &lt;expr6&gt;                 =&gt; sub &lt;expr5&gt; &lt;expr6&gt;;

&lt;expr5&gt; ::= &lt;expr6&gt;;

&lt;expr6&gt; ::= &lt;expr6&gt; mul &lt;expr7&gt;                 =&gt; mul &lt;expr6&gt; &lt;expr7&gt;;

&lt;expr6&gt; ::= &lt;expr6&gt; div &lt;expr7&gt;                 =&gt; div &lt;expr6&gt; &lt;expr7&gt;;

&lt;expr6&gt; ::= &lt;expr6&gt; mod &lt;expr7&gt;                 =&gt; mod &lt;expr6&gt; &lt;expr7&gt;;

&lt;expr6&gt; ::= &lt;expr7&gt;;

&lt;expr7&gt; ::= not &lt;expr8&gt;;

&lt;expr7&gt; ::= s_minus &lt;expr8&gt;;

&lt;expr7&gt; ::= inc &lt;expr8&gt;;

&lt;expr7&gt; ::= dec &lt;expr8&gt;;

&lt;expr7&gt; ::= typeof &lt;expr8&gt;;

&lt;expr7&gt; ::= new &lt;expr8&gt; lparen &lt;params&gt; rparen =&gt; new &lt;expr8&gt; &lt;params&gt;;

&lt;expr7&gt; ::= &lt;expr8&gt;;

&lt;expr8&gt; ::= &lt;expr8&gt; dot ident                   =&gt; dot &lt;expr8&gt; ident;

&lt;expr8&gt; ::= lparen &lt;expr&gt; rparen                =&gt; &lt;expr&gt;;

&lt;expr8&gt; ::= &lt;expr8&gt; lsqr &lt;expr&gt; rsqr            =&gt; array &lt;expr8&gt; &lt;expr&gt;;

&lt;expr8&gt; ::= &lt;expr8&gt; lparen &lt;params&gt; rparen      =&gt; funcall &lt;expr8&gt; &lt;params&gt;;

&lt;params&gt; ::= &lt;expr&gt; comma &lt;params&gt;;

&lt;params&gt; ::= &lt;expr&gt; ;

&lt;params&gt; ::= NULL;

&lt;expr8&gt; ::= lcurly &lt;params&gt; rcurly;

&lt;expr8&gt; ::= float;

&lt;expr8&gt; ::= ident;

&lt;expr8&gt; ::= integer;

&lt;expr8&gt; ::= string;

&lt;expr8&gt; ::= function lparen &lt;param_list&gt; rparen lcurly &lt;statements&gt; rcurly

    =&gt; lambda &lt;param_list&gt; &lt;statements&gt;;

&lt;for_block&gt; ::= for lparen &lt;nullable_expr&gt; semicolon &lt;nullable_expr&gt; semicolon &lt;nullable_expr&gt; rparen lcurly &lt;statements&gt; rcurly

    =&gt; &lt;nullable_expr&gt; &lt;nullable_expr&gt; &lt;nullable_expr&gt; &lt;statements&gt;;

&lt;nullable_expr&gt; ::= &lt;expr&gt;;

&lt;nullable_expr&gt; ::= NULL;

&lt;while_block&gt; ::= while lparen &lt;expr&gt; rparen lcurly &lt;statements&gt; rcurly

    =&gt; &lt;expr&gt; &lt;statements&gt;;

&lt;try_block&gt; ::= try lcurly &lt;hooked_statements&gt; rcurly catch lparen ident rparen

    lcurly &lt;hooked_statements&gt; rcurly finally lcurly &lt;statements&gt; rcurly

    =&gt; &lt;hooked_statements&gt; ident &lt;hooked_statements&gt; &lt;statements&gt;;

%equiv &lt;statements&gt; &lt;hooked_statements&gt;;

&lt;hooked_statements&gt; ::= &lt;hooked_statement&gt; &lt;hooked_statements&gt;;

&lt;hooked_statements&gt; ::= NULL;

%equiv &lt;statement&gt; &lt;hooked_statement&gt; &lt;hooked_fc_statement&gt;;

&lt;hooked_statement&gt; ::= &lt;flow_statement&gt;;

&lt;hooked_statement&gt; ::= &lt;expr_statement&gt;;

&lt;hooked_statement&gt; ::= &lt;hooked_fc_statement&gt;;

&lt;hooked_statement&gt; ::= &lt;throw_exception&gt;;

&lt;hooked_fc_statement&gt; ::= &lt;hooked_return_val&gt;;

&lt;hooked_fc_statement&gt; ::= &lt;hooked_return_void&gt;;

&lt;hooked_fc_statement&gt; ::= &lt;hooked_break&gt;;

&lt;hooked_fc_statement&gt; ::= &lt;hooked_continue&gt;;

&lt;hooked_return_val&gt; ::= return &lt;expr&gt; semicolon =&gt; &lt;expr&gt;;

&lt;hooked_return_void&gt; ::= return semicolon;

&lt;hooked_break&gt; ::= break semicolon;

&lt;hooked_continue&gt; ::= continue semicolon;

&lt;switch_block&gt; ::= switch lparen &lt;expr&gt; rparen lcurly &lt;switch_cases&gt; &lt;default_case&gt; rcurly

    =&gt; &lt;expr&gt; &lt;switch_cases&gt; &lt;default_case&gt;;

&lt;switch_block&gt; ::= switch lparen &lt;expr&gt; rparen lcurly &lt;switch_cases&gt; rcurly

    =&gt; &lt;expr&gt; &lt;switch_cases&gt;;

%array &lt;switch_cases&gt;;

&lt;switch_cases&gt; ::= &lt;switch_case&gt; &lt;switch_cases&gt;;

&lt;switch_cases&gt; ::= NULL;

&lt;switch_case&gt; ::= case &lt;expr&gt; colon &lt;statements&gt;

    =&gt; &lt;expr&gt; &lt;statements&gt;;

&lt;default_case&gt; ::= default colon &lt;statements&gt;

    =&gt; &lt;statements&gt;;
</code></pre>
]]></description>
                </item>
                                <item>
                    <title>﻿ngscript之二：语法分析</title>
                    <link>http://wssccc.github.io/blog/ngscript-part-3</link>
                    <guid>http://wssccc.github.io/blog/ngscript-part-3</guid>
                    <pubDate>2014-03-06 19:07</pubDate>
                    <description><![CDATA[<p>ngscript的语法分析使用的是我自己的语法分析工具<a href="https://github.com/wssccc/parseroid.git">parseroid</a>。与常用cc工具（yacc、bison、javacc、antlr、etc…）不同的是，parseroid生成的不是语法分析器的源程序，而是一个parser对象，直接可以用来执行parsing。也就是说，可以由BNF在执行阶段动态生成parser。</p>

<p>生成parser的action table运算量还是有点大，所以在新版的parseroid里面table改成了serializable的，可以缓存下来免去生成table的过程。</p>

<h2>实现parseroid</h2>

<h3>文法描述</h3>

<p>parseroid使用LALR(1)文法。</p>

<p>parseroid使用的文法描述文件是这个样子</p>

<pre><code>//starter symbol 

%start &lt;program&gt;;

%array &lt;statements&gt; &lt;param_list&gt; &lt;params&gt;;

%equiv &lt;expr&gt; &lt;expr1&gt; &lt;expr2&gt; &lt;expr3&gt; &lt;expr4&gt; &lt;expr5&gt; &lt;expr6&gt; &lt;expr7&gt; &lt;expr8&gt; &lt;nullable_expr&gt;;

%filter semicolon comma;



&lt;program&gt; ::= &lt;statements&gt;;

//----------------------------------------------------------------------------

//statements is a collection of statement;

&lt;statements&gt; ::= NULL;

&lt;statements&gt; ::= &lt;statement&gt; &lt;statements&gt;;

//省略一些

&lt;throw_exception&gt; ::= throw &lt;expr&gt; semicolon =&gt; &lt;expr&gt;;

//再省略一些
</code></pre>

<p>%开头的是注记，有这几种</p>

<ul>
<li><p>%start 指定一个起始符</p></li>
<li><p>%equiv 标记等价类，在生成语法树之后的reduce过程中，会把等价类合并</p></li>
<li><p>%filter 也是在reduce过程中，会把这些节点去掉</p></li>
<li><p>=> 标记的用处是在规约生成语法树的时候调整AST，如这句 <code>&lt;throw_exception&gt; ::= throw &lt;expr&gt; semicolon =&gt; &lt;expr&gt;;</code> <br/>这句的意思是用throw <expr> semicolon的结构规约到<throw_exception>，但是只保存<expr>这个元素，主要是为了后面处理语法树方便和看起来更加顺眼……</p></li>
</ul>

<h3>实现</h3>

<p>LALR（1）的具体细节书本上都有，就不再阐述了。</p>

<h3>错误恢复</h3>

<p>parseroid使用error符号错误恢复。</p>

<p>具体做法是写这样的产生式<code>&lt;statements&gt; ::= error semicolon &lt;statements&gt;;</code></p>

<p>效果是，在遇到statements中的错误之后，会把错误部分parsing为一个error节点，然后同步到semicolon的位置继续parsing。</p>

<p>具体过程</p>

<ul>
<li><p>不断的弹出栈顶，直到一个特定的状态，在该状态中error符号的动作为移进。</p></li>
<li><p>移进error符号</p></li>
<li><p>不断丢弃输入符号，直到一个特定的向前查看符号，它在当前状态，对应一个非出错的动作。</p></li>
<li><p>重新开始正常分析</p></li>
</ul>

<h3>语法树简化</h3>

<ul>
<li><p>合并等价类</p></li>
<li><p>删除无用的嵌套</p></li>
<li><p>删除不必要的节点</p></li>
</ul>

<p>合并等价类是因为在parseroid的文法描述中，没有显式指定算符的优先级，需要使用产生式的层次来表现。</p>

<p>于是就有很多<code>&lt;expr1&gt;</code> <code>&lt;expr2&gt;</code>这种东西，但是他们实质上都可以当成expr来处理。</p>

<p>无用的嵌套是因为在<code>&lt;expr1&gt;</code>这种化为<code>&lt;expr&gt;</code>之后，可能出现如<code>&lt;expr&gt; -&gt; &lt;expr&gt; -&gt; number</code>这种，也是可以简化的。</p>

<p>不必要的节点，就是左括号右括号这种。</p>

<p>parseroid源代码在这里</p>

<p><a href="https://github.com/wssccc/parseroid.git">https://github.com/wssccc/parseroid.git</a></p>

<p>后面我会用lexeroid和parseroid实现ngscript的解析器。</p>

<h2>其它分析方法的介绍</h2>

<p>语法分析的方法有很多，简单介绍一下。</p>

<h3>SLR(1)</h3>

<p>编译原理的大作业就是实现SLR（1），可以处理这样的文法</p>

<pre><code>S-&gt;# Ee #

Ee-&gt;Ee + Ti|Ee - Ti|Ti

Ti-&gt;Ti * Ff|Ti / Ff|Ff

Ff-&gt;( Ee )|d

Ff-&gt;sin Ff

Ff-&gt;cos Ff
</code></pre>

<p>当时觉得只要文法改改就能用，后来真正用的时候才发现是个坑……</p>

<p>书上是把它当过渡方法来讲的</p>

<h3>Parser组合子</h3>

<p>最开始知道这个是在</p>

<p>这里 <a href="http://www.cnblogs.com/Ninputer/archive/2011/06/26/2090645.html">自己动手开发编译器（八）用Linq编写解析器组合子</a></p>

<p>这里 <a href="http://www.ibm.com/developerworks/cn/java/j-lo-compose/">利用 Java 实现组合式解析器</a></p>

<p>还有这里 <a href="http://www.cnblogs.com/Ninputer/archive/2011/07/03/2096944.html">自己动手开发编译器（九）CPS风格的解析器组合子</a></p>

<p>我也用Java实现了一个，因为Java没有lambda，硬是用匿名类整了出来。也是CPS的，带错误恢复。</p>

<p>运行起来大概是这样</p>

<p><img src="java-cps-parser.jpg" alt="java-cps-parser.jpg" /></p>

<p>不过解析器组合子的缺点也很明显，就是太难调试了。而且文法是用代码的形式在程序中描述的，太复杂之后我就被绕晕了 = =</p>

<h3>LL（1）</h3>

<p>LL（1）应该算是比较容易实现的，不过需要对文法做一些调整，消除左递归，提取左公因式什么的，后来写到二元运算符的文法我还是觉得LL（1）不能忍。</p>

<h3>LALR（1）</h3>

<p>书上介绍分析方法的顺序LALR（1）一般是排在最后的，按这种设定应该是这个最靠谱了。</p>

<p>附一张图：</p>

<p><img src="grammar-cascade.jpg" alt="grammar-cascade.jpg" /></p>
]]></description>
                </item>
                                <item>
                    <title>ngscript之一：词法分析</title>
                    <link>http://wssccc.github.io/blog/ngscript-part-2</link>
                    <guid>http://wssccc.github.io/blog/ngscript-part-2</guid>
                    <pubDate>2014-03-04 13:35</pubDate>
                    <description><![CDATA[<p>正则表达式的理论基础可以参考<a href="http://home.cnblogs.com/u/Ninputer/">装配脑袋</a>的</p>

<ul>
<li><p>这个 <a href="http://www.cnblogs.com/Ninputer/archive/2011/06/08/2075714.html">自己动手开发编译器（二）正则语言和正则表达式</a></p></li>
<li><p>这个 <a href="http://www.cnblogs.com/Ninputer/archive/2011/06/10/2077991.html">自己动手开发编译器（三）有穷自动机</a></p></li>
<li><p>还有这个 <a href="http://www.cnblogs.com/Ninputer/archive/2011/06/12/2078671.html">自己动手开发编译器（四）利用DFA转换表建立扫描器</a></p></li>
</ul>

<p>如果学过编译原理的课程就更好了。</p>

<p>词法分析用到了我写的一个工具lexeroid。</p>

<p>下面说一些我写lexeroid时候遇到的问题。</p>

<h2>Unicode</h2>

<p>在装配脑袋的<a href="http://www.cnblogs.com/Ninputer/archive/2011/06/12/2078671.html">自己动手开发编译器（四）利用DFA转换表建立扫描器</a> 中，提到了等价类处理Unicode的方法。</p>

<p>我做了一些改进。</p>

<p>在lexeroid中，所有的已定义字符都会注册，等Regex定义完成，开始生成DFA之前，会把所有的Any转换为undefined和每个已注册类。</p>

<p>如果定义的逻辑是not，则会在替换的时候排除掉这些字符。</p>

<p>这样就没有lexeroid之前的冲突处理过程了。 </p>

<h2>最长匹配</h2>

<p>这个很多书上应该介绍过，就是设置一个lastFinal一样的东西，然后在DFA停机的时候把最后一个正确匹配的取出来。</p>

<h2>NFA的组织</h2>

<p>最开始我做的是把每个token的NFA分开，存成一个数组，然后每个生成DFA之后，在词法分析的时候一个一个去测试。后来发现这个似乎和用Java内置的正则表达式没什么区别。而且有一个问题是，token定义的顺序要十分小心，因为先定义的token会被优先匹配到。</p>

<p>后来我试了另外一种方法，就是等所有token生成NFA完之后，添加一个入口，用epsilon边把所有的NFA连起来形成一个大NFA，然后再用它生成的DFA去匹配。</p>

<h2>最后</h2>

<p>lexeroid定义token时大概是这个样子(目前lexeroid已经支持从字符串parse出Regex)</p>

<pre class="brush: java">

    LexerBuilder builder = new LexerBuilder();

    builder.defineToken("if", Re.string("if"));

    builder.defineToken("return", Re.string("return"));

    builder.defineToken("else", Re.string("else"));

    builder.defineToken("ident", Re.concat(

            Re.or(Re.letter(), Re.chr('_')),

            Re.many(Re.or(Re.or(Re.letter(), Re.chr('_')), Re.digit()))

    ));

    builder.defineToken("string",

            Re.concat(Re.chr('"'), Re.many(Re.char1()), Re.chr('"'))

    );



      //此处省略N行

      return builder.build();

</pre>

<p>代码可以从这里找到</p>

<p><a href="https://github.com/wssccc/lexeroid.git">https://github.com/wssccc/lexeroid.git</a></p>

<p>作为一个词法分析器，后面的文章中还会用到它。</p>

<p>相关资料</p>

<ul>
<li><p><a href="http://www.cnblogs.com/geniusvczh/p/3577561.html">跟vczh看实例学编译原理——二：实现Tinymoe的词法分析</a></p></li>
<li><p><a href="http://www.cnblogs.com/Ninputer/archive/2011/06/08/2075714.html">自己动手开发编译器（二）正则语言和正则表达式</a></p></li>
<li><p><a href="http://www.cnblogs.com/Ninputer/archive/2011/06/10/2077991.html">自己动手开发编译器（三）有穷自动机</a></p></li>
<li><p><a href="http://www.cnblogs.com/Ninputer/archive/2011/06/12/2078671.html">自己动手开发编译器（四）利用DFA转换表建立扫描器</a></p></li>
</ul>
]]></description>
                </item>
                                <item>
                    <title>ngscript之零</title>
                    <link>http://wssccc.github.io/blog/ngscript-part-1</link>
                    <guid>http://wssccc.github.io/blog/ngscript-part-1</guid>
                    <pubDate>2014-03-04 12:04</pubDate>
                    <description><![CDATA[<p>正式开始介绍前先扯点没用的。</p>

<p>从小玩basic长大的小朋友大多有一个梦想，就是自己实现一个basic解释器。</p>

<p>不过这里我实现的不是basic，而是一个语法和功能类似javascript的东西。</p>

<p>暂且称之为ngscript</p>

<p><strong>做这个的初衷是想试试不借助任何cc工具，只用java和一些语言的基础设施来实现一个脚本解释器。</strong></p>

<p>不使用cc工具有以下原因</p>

<ul>
<li><p>语法蛋疼</p></li>
<li><p>调试麻烦</p></li>
<li><p>不知其所以然</p></li>
</ul>

<p>很多书上把常用的parsing方法介绍一通，然后就去折腾sablecc,yacc去了（貌似还有一本书是专门讲yacc和lex的）</p>

<p>后来看了<a href="http://www.cnblogs.com/Ninputer/archive/2011/06/06/2073908.html">这个系列</a>，受到了一些启发。不过里面使用的是C#，有好用的lambda。</p>

<p>我也曾试着用java的匿名类机制实现了一个parser combinator 一样的东西，那真是痛苦的经历…</p>

<p>现在ngscript使用的是LALR(1)的分析方法，分析工具是我自己实现的一个能读入bnf动态生成分析器的东西。</p>

<p>从下一篇开始我会把各个部分介绍一遍。</p>
]]></description>
                </item>
                        </channel>
    </rss>
    